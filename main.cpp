#include <avr/io.h>
#include <stdint.h>
#include <avr/interrupt.h>


#define BAUD 9600
#define UART_UBRR F_CPU / 16 / BAUD - 1
#define ARRAY_LEN(arr) sizeof(arr) / (sizeof((arr)[0]))

/* ======================================== Task context ======================================== */
typedef uint8_t StackType_t;
typedef void(*TaskFunction_t)(void*);
#define portFLAGS_INT_ENABLED ((StackType_t)0x80)

enum class status { OK, NOK };

class scope_lock {
	uint8_t enabled_interrupts_{};
public:
	scope_lock(const scope_lock&)			= delete;
	scope_lock(scope_lock&&)			= delete;
	scope_lock& operator=(const scope_lock&)	= delete;
	scope_lock& operator=(scope_lock&&)		= delete;

	scope_lock() {
		enabled_interrupts_ = SREG;
		cli();
	}
	~scope_lock() {
		SREG = enabled_interrupts_;
		asm volatile( "" ::: "memory" );
	}
};

struct TCB_t {
	/**
	* Points to the location of the last item placed on the tasks stack.
	* THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT.
	*/
	StackType_t* pxTopOfStack;
	StackType_t* pxStack = &bs_stack[ARRAY_LEN(bs_stack) - 1]; /* Start of the stack */
	StackType_t bs_stack[128+64] = { 0, };
};

TCB_t* pxCurrentTCB{nullptr};

constexpr int TASK_MAX{8};
static TCB_t task_tcbs[TASK_MAX] = { {nullptr, }, };
static uint16_t task_current{0};
static uint16_t task_total{0};

static StackType_t* pxPortInitialiseStack(
	StackType_t* pxTopOfStack, TaskFunction_t pxCode, void *const pvParameters)
{
	uint16_t usAddress;
	/* Simulate how the stack would look after a call to vPortYield() generated by
	 * the compiler. */

	/* The start of the task code will be popped off the stack last, so place
	 * it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
	pxTopOfStack--;

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	 * portSAVE_CONTEXT places the flags on the stack immediately after r0
	 * to ensure the interrupts get disabled as soon as possible, and so ensuring
	 * the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;    /* R0 */
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
	pxTopOfStack--;

	/* Now the remaining registers. The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;    /* R1 */

	/* Leave R2 - R23 untouched */
	pxTopOfStack -= 23;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );

	/* Leave register R26 - R31 untouched */
	pxTopOfStack -= 7;

	return pxTopOfStack;
}

static status addTask(TaskFunction_t pxTaskCode, void *const pvParameters)
{
	scope_lock sl{};
	if (task_total >= TASK_MAX) {
		return status::NOK;
	}

	TCB_t* newTCB = &task_tcbs[task_total++];
	newTCB->pxTopOfStack = pxPortInitialiseStack(newTCB->pxStack, pxTaskCode, pvParameters);
	asm volatile( "" ::: "memory" );
	pxCurrentTCB = newTCB;
	return status::OK;
}

#define RESTORE_CONTEXT()                                                                       \
		__asm__ __volatile__ (  "lds    r26, pxCurrentTCB                       \n\t"   \
					"lds    r27, pxCurrentTCB + 1                   \n\t"   \
					"ld     r28, x+                                 \n\t"   \
					"out    __SP_L__, r28                           \n\t"   \
					"ld     r29, x+                                 \n\t"   \
					"out    __SP_H__, r29                           \n\t"   \
					"pop    r31                                     \n\t"   \
					"pop    r30                                     \n\t"   \
					"pop    r29                                     \n\t"   \
					"pop    r28                                     \n\t"   \
					"pop    r27                                     \n\t"   \
					"pop    r26                                     \n\t"   \
					"pop    r25                                     \n\t"   \
					"pop    r24                                     \n\t"   \
					"pop    r23                                     \n\t"   \
					"pop    r22                                     \n\t"   \
					"pop    r21                                     \n\t"   \
					"pop    r20                                     \n\t"   \
					"pop    r19                                     \n\t"   \
					"pop    r18                                     \n\t"   \
					"pop    r17                                     \n\t"   \
					"pop    r16                                     \n\t"   \
					"pop    r15                                     \n\t"   \
					"pop    r14                                     \n\t"   \
					"pop    r13                                     \n\t"   \
					"pop    r12                                     \n\t"   \
					"pop    r11                                     \n\t"   \
					"pop    r10                                     \n\t"   \
					"pop    r9                                      \n\t"   \
					"pop    r8                                      \n\t"   \
					"pop    r7                                      \n\t"   \
					"pop    r6                                      \n\t"   \
					"pop    r5                                      \n\t"   \
					"pop    r4                                      \n\t"   \
					"pop    r3                                      \n\t"   \
					"pop    r2                                      \n\t"   \
					"pop    __zero_reg__                            \n\t"   \
					"pop    __tmp_reg__                             \n\t"   \
					"out    __SREG__, __tmp_reg__                   \n\t"   \
					"pop    __tmp_reg__                             \n\t"   \
				);

#define SAVE_CONTEXT()                                                                          \
		__asm__ __volatile__ (  "push   __tmp_reg__                             \n\t"   \
					"in     __tmp_reg__, __SREG__                   \n\t"   \
					"cli                                            \n\t"   \
					"push   __tmp_reg__                             \n\t"   \
					"push   __zero_reg__                            \n\t"   \
					"clr    __zero_reg__                            \n\t"   \
					"push   r2                                      \n\t"   \
					"push   r3                                      \n\t"   \
					"push   r4                                      \n\t"   \
					"push   r5                                      \n\t"   \
					"push   r6                                      \n\t"   \
					"push   r7                                      \n\t"   \
					"push   r8                                      \n\t"   \
					"push   r9                                      \n\t"   \
					"push   r10                                     \n\t"   \
					"push   r11                                     \n\t"   \
					"push   r12                                     \n\t"   \
					"push   r13                                     \n\t"   \
					"push   r14                                     \n\t"   \
					"push   r15                                     \n\t"   \
					"push   r16                                     \n\t"   \
					"push   r17                                     \n\t"   \
					"push   r18                                     \n\t"   \
					"push   r19                                     \n\t"   \
					"push   r20                                     \n\t"   \
					"push   r21                                     \n\t"   \
					"push   r22                                     \n\t"   \
					"push   r23                                     \n\t"   \
					"push   r24                                     \n\t"   \
					"push   r25                                     \n\t"   \
					"push   r26                                     \n\t"   \
					"push   r27                                     \n\t"   \
					"push   r28                                     \n\t"   \
					"push   r29                                     \n\t"   \
					"push   r30                                     \n\t"   \
					"push   r31                                     \n\t"   \
					"lds    r26, pxCurrentTCB                       \n\t"   \
					"lds    r27, pxCurrentTCB + 1                   \n\t"   \
					"in     __tmp_reg__, __SP_L__                   \n\t"   \
					"st     x+, __tmp_reg__                         \n\t"   \
					"in     __tmp_reg__, __SP_H__                   \n\t"   \
					"st     x+, __tmp_reg__                         \n\t"   \
				);

static void startTasks()
{
	task_current = task_total - 1;

	/* Restore the context of the first task that is going to run. */
	RESTORE_CONTEXT();

	/* Simulate a function call end as generated by the compiler. We will now
	 * jump to the start of the task the context of which we have just restored. */
	__asm__ __volatile__ ( "ret" );
}

static uint32_t jiffies{0};

static void switchTask()
{
	SAVE_CONTEXT();
	task_current++;
	if (task_current >= task_total) {
		task_current = 0;
	}
	pxCurrentTCB = &task_tcbs[task_current];
	jiffies++;
	asm volatile( "" ::: "memory" );
	RESTORE_CONTEXT();
}

static void wait_desiseconds(uint32_t duration)
{
	uint32_t epoch = jiffies;
	while ((jiffies - epoch) < duration) {
		asm volatile( "" ::: "memory" );
	}
}

/* =========================================== Timer =========================================== */
static void TIMER_init()
{
	constexpr uint16_t timer_clock_prescaler = 1024;
	TCCR1B |= (1 << WGM12);				/* Select CTC mode of Timer1 */
	TIMSK1 |= (1 << OCIE1A);			/* Enable timer compare interrupt */
	TCCR1B |= (1 << CS12) | (1 << CS10);		/* Timer clock prescaler 1024 */
	OCR1A = F_CPU / timer_clock_prescaler / 10;	/* Output compare register A to get 10Hz */
}

ISR(TIMER1_COMPA_vect, ISR_NAKED)
{
	switchTask();
	__asm__ __volatile__ ( "reti" );
}

/* =========================================== Usart =========================================== */
static void USART_Init(uint16_t ubrr)
{
	UBRR0 = ubrr;				/* Set baud rate */
	UCSR0B = (1 << RXEN0)  | (1 << TXEN0);	/* Enable receiver and transmitter */
	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);	/* Set frame format: 8data, 1 stop bit */
}

static void USART_Transmit(unsigned char data)
{
	while (!(UCSR0A & (1 << UDRE0))) { }	/* Wait for empty transmit buffer */
	UDR0 = data;				/* Put data into buffer to send the data */
}

/* ============================================ App ============================================ */
static void task_uart(void* p)
{
	static_cast<void>(p);
	unsigned char data = '\0';
	while (true) {
		USART_Transmit(data++);
		wait_desiseconds(5);
	}
}

static void task_slow(void* p)
{
	for ( ; ; ) {
		for (int i = 0; i < 8; i++) {
			wait_desiseconds(8);
			PORTB ^= *((uint8_t*)p);
		}
		for (int i = 0; i < 8; i++) {
			wait_desiseconds(3);
			PORTB ^= *((uint8_t*)p);
		}
	}
}

static void task_fast(void* p)
{
	uint8_t mask = *((uint8_t*)p);

	for ( ; ; ) {
		wait_desiseconds(2);
		PORTB ^= mask;
	}
}

int main()
{
	static uint8_t led5_mask = 0b00100000;
	uint8_t led4_mask = 1 << PB4;

	DDRB  |= led5_mask | (1 << PB4);

	USART_Init(UART_UBRR);
	TIMER_init();
	sei();

	addTask(task_uart, nullptr);
	addTask(task_slow, &led5_mask);
	addTask(task_fast, &led4_mask);

	startTasks();

	while (true) {
		PORTB ^= led5_mask;
	}

	return 0;
}
