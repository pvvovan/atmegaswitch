#include <avr/io.h>
#include <util/delay.h>
#include <stdint.h>
#include <stddef.h>
#include <avr/interrupt.h>

static constexpr uint8_t PB5_MASK {0b0010'0000};

struct TaskControlBlock_t;
typedef struct TaskControlBlock_t* TaskHandle_t;

typedef int8_t                      BaseType_t;
typedef uint8_t                     UBaseType_t;
typedef uint8_t                     StackType_t;
typedef void (* TaskFunction_t)( void * );
#define portFLAGS_INT_ENABLED           ( (StackType_t) 0x80 )


typedef struct xMEMORY_REGION
{
	void* pvBaseAddress;
	uint32_t ulLengthInBytes;
	uint32_t ulParameters;
} MemoryRegion_t;

struct TCB_t
{
	/**
	 * Points to the location of the last item placed on the tasks stack.
	 * THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT.
	 */
	volatile StackType_t* pxTopOfStack;
	StackType_t* pxStack = &bs_stack[255]; /*< Points to the start of the stack. */
	StackType_t bs_stack[256];
};
volatile TCB_t* volatile pxCurrentTCB {nullptr};

constexpr int TASK_MAX {4};
static TCB_t task_tcbs[TASK_MAX];
static uint16_t task_n{0};

static StackType_t* pxPortInitialiseStack(StackType_t* pxTopOfStack, TaskFunction_t pxCode, void* pvParameters)
{
	uint16_t usAddress;
	/* Simulate how the stack would look after a call to vPortYield() generated by
	   the compiler. */

	/* The start of the task code will be popped off the stack last, so place
	   it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
	pxTopOfStack--;

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	   portSAVE_CONTEXT places the flags on the stack immediately after r0
	   to ensure the interrupts get disabled as soon as possible, and so ensuring
	   the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;    /* R0 */
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
	pxTopOfStack--;

	/* Now the remaining registers. The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;    /* R1 */

	/* Leave R2 - R23 untouched */
	pxTopOfStack -= 23;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );

	/* Leave register R26 - R31 untouched */
	pxTopOfStack -= 7;

	return pxTopOfStack;
}

static void prvInitialiseNewTask( TaskFunction_t pxTaskCode,
								void * const pvParameters,
								TCB_t * pxNewTCB )
{
	StackType_t* pxTopOfStack;

	/* Calculate the top of stack address. This depends on whether the stack
	   grows from high memory to low (as per the 80x86) or vice versa.
	   portSTACK_GROWTH is used to make the result positive or negative as required
	   by the port. */
	pxTopOfStack = pxNewTCB->pxStack;

	/* Initialize the TCB stack to look as if the task was already running,
	   but had been interrupted by the scheduler.  The return address is set
	   to the start of the task function. Once the stack has been initialised
	   the top of stack variable is updated. */
	pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
}

static void AddTask(TaskFunction_t pxTaskCode, void * const pvParameters)
{
	TCB_t* pxNewTCB = &task_tcbs[task_n++];
	if (task_n >= TASK_MAX) { task_n = 0; }

	prvInitialiseNewTask(pxTaskCode, pvParameters, pxNewTCB);
	pxCurrentTCB = pxNewTCB;
}


#define portRESTORE_CONTEXT()                                                           \
		__asm__ __volatile__ (  "lds    r26, pxCurrentTCB                       \n\t"   \
								"lds    r27, pxCurrentTCB + 1                   \n\t"   \
								"ld     r28, x+                                 \n\t"   \
								"out    __SP_L__, r28                           \n\t"   \
								"ld     r29, x+                                 \n\t"   \
								"out    __SP_H__, r29                           \n\t"   \
								"pop    r31                                     \n\t"   \
								"pop    r30                                     \n\t"   \
								"pop    r29                                     \n\t"   \
								"pop    r28                                     \n\t"   \
								"pop    r27                                     \n\t"   \
								"pop    r26                                     \n\t"   \
								"pop    r25                                     \n\t"   \
								"pop    r24                                     \n\t"   \
								"pop    r23                                     \n\t"   \
								"pop    r22                                     \n\t"   \
								"pop    r21                                     \n\t"   \
								"pop    r20                                     \n\t"   \
								"pop    r19                                     \n\t"   \
								"pop    r18                                     \n\t"   \
								"pop    r17                                     \n\t"   \
								"pop    r16                                     \n\t"   \
								"pop    r15                                     \n\t"   \
								"pop    r14                                     \n\t"   \
								"pop    r13                                     \n\t"   \
								"pop    r12                                     \n\t"   \
								"pop    r11                                     \n\t"   \
								"pop    r10                                     \n\t"   \
								"pop    r9                                      \n\t"   \
								"pop    r8                                      \n\t"   \
								"pop    r7                                      \n\t"   \
								"pop    r6                                      \n\t"   \
								"pop    r5                                      \n\t"   \
								"pop    r4                                      \n\t"   \
								"pop    r3                                      \n\t"   \
								"pop    r2                                      \n\t"   \
								"pop    __zero_reg__                            \n\t"   \
								"pop    __tmp_reg__                             \n\t"   \
								"out    __SREG__, __tmp_reg__                   \n\t"   \
								"pop    __tmp_reg__                             \n\t"   \
							);

#define portSAVE_CONTEXT()                                                              \
		__asm__ __volatile__ (  "push   __tmp_reg__                             \n\t"   \
								"in     __tmp_reg__, __SREG__                   \n\t"   \
								"cli                                            \n\t"   \
								"push   __tmp_reg__                             \n\t"   \
								"push   __zero_reg__                            \n\t"   \
								"clr    __zero_reg__                            \n\t"   \
								"push   r2                                      \n\t"   \
								"push   r3                                      \n\t"   \
								"push   r4                                      \n\t"   \
								"push   r5                                      \n\t"   \
								"push   r6                                      \n\t"   \
								"push   r7                                      \n\t"   \
								"push   r8                                      \n\t"   \
								"push   r9                                      \n\t"   \
								"push   r10                                     \n\t"   \
								"push   r11                                     \n\t"   \
								"push   r12                                     \n\t"   \
								"push   r13                                     \n\t"   \
								"push   r14                                     \n\t"   \
								"push   r15                                     \n\t"   \
								"push   r16                                     \n\t"   \
								"push   r17                                     \n\t"   \
								"push   r18                                     \n\t"   \
								"push   r19                                     \n\t"   \
								"push   r20                                     \n\t"   \
								"push   r21                                     \n\t"   \
								"push   r22                                     \n\t"   \
								"push   r23                                     \n\t"   \
								"push   r24                                     \n\t"   \
								"push   r25                                     \n\t"   \
								"push   r26                                     \n\t"   \
								"push   r27                                     \n\t"   \
								"push   r28                                     \n\t"   \
								"push   r29                                     \n\t"   \
								"push   r30                                     \n\t"   \
								"push   r31                                     \n\t"   \
								"lds    r26, pxCurrentTCB                       \n\t"   \
								"lds    r27, pxCurrentTCB + 1                   \n\t"   \
								"in     __tmp_reg__, __SP_L__                   \n\t"   \
								"st     x+, __tmp_reg__                         \n\t"   \
								"in     __tmp_reg__, __SP_H__                   \n\t"   \
								"st     x+, __tmp_reg__                         \n\t"   \
							);


static void slow(void* p)
{
	for ( ; ; ) {
		for (int i = 0; i < 5; i++) {
			_delay_ms(1000);
			PORTB ^= *((uint8_t*)p);
		}
		for (int i = 0; i < 17; i++) {
			_delay_ms(300);
			PORTB ^= *((uint8_t*)p);
		}
	}
}

static void fast(void* p)
{
	uint8_t mask = *((uint8_t*)p);

	for ( ; ; ) {
		_delay_ms(100);
		PORTB ^= mask;
	}
}

static void start() {
	static uint8_t led_mask = 0b00100000;

	AddTask(slow, &led_mask);
	AddTask(fast, &led_mask);
	task_n = 1;

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();

	/* Simulate a function call end as generated by the compiler. We will now
	   jump to the start of the task the context of which we have just restored. */
	__asm__ __volatile__ ( "ret" );
}

static void timer_init()
{
	TCCR1B |= (1 << WGM12);					/* Select CTC mode of Timer1 */
	TIMSK1 |= (1 << OCIE1A);				/* Enable timer compare interrupt */
	OCR1AH = 0xFF;							/* Output compare register A high byte */
	OCR1AL = 0xFF;							/* Output compare register A low byte */
	TCCR1B |= (1 << CS12) | (1 << CS10);	/* Timer clock prescaler 1024 */
}

ISR (TIMER1_COMPA_vect, ISR_NAKED)
{
	portSAVE_CONTEXT();
	task_n = (task_n == 1) ? 0 : 1;
	pxCurrentTCB = &task_tcbs[task_n];
	portRESTORE_CONTEXT();
	__asm__ __volatile__ ( "reti" );
}

int main()
{
	PORTB |= PB5_MASK;
	DDRB  |= PB5_MASK;

	timer_init();
	sei();

	start();

	while (true) {
		_delay_ms(2500);
		PORTB ^= PB5_MASK;
	}

	return 0;
}
