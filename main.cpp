#include <avr/io.h>
#include <util/delay.h>
#include <stdint.h>
#include <stddef.h>
#include <avr/interrupt.h>

static constexpr uint8_t PB5_MASK {0b0010'0000};

/* ================================================================================================================ */
uint8_t ctx[512];

struct TaskControlBlock_t;
typedef struct TaskControlBlock_t* TaskHandle_t;

typedef int8_t                      BaseType_t;
typedef uint8_t                     UBaseType_t;
typedef uint8_t                     StackType_t;
typedef void (* TaskFunction_t)( void * );
#define portFLAGS_INT_ENABLED           ( (StackType_t) 0x80 )


typedef struct xMEMORY_REGION
{
	void * pvBaseAddress;
	uint32_t ulLengthInBytes;
	uint32_t ulParameters;
} MemoryRegion_t;

typedef struct tskTaskControlBlock       /* The old naming convention is used to prevent breaking kernel aware debuggers. */
{
	volatile StackType_t * pxTopOfStack; /*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
	StackType_t * pxStack;                      /*< Points to the start of the stack. */
	char pcTaskName[ 8 ]; /*< Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
} TCB_t;
volatile TCB_t * volatile pxCurrentTCB;

static volatile uint8_t uxCurrentNumberOfTasks = ( uint8_t ) 0U;


StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
uint16_t usAddress;
	/* Simulate how the stack would look after a call to vPortYield() generated by
	the compiler. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
	pxTopOfStack--;

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;    /* R0 */
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
	pxTopOfStack--;

	/* Now the remaining registers. The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;    /* R1 */

	/* Leave R2 - R23 untouched */
	pxTopOfStack -= 23;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );

	/* Leave register R26 - R31 untouched */
	pxTopOfStack -= 7;

	return pxTopOfStack;
}

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	* updated. */
	{
		uxCurrentNumberOfTasks++;

		if( pxCurrentTCB == NULL )
		{
			/* There are no other tasks, or all the other tasks are in
			* the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
			{
				/* This is the first task to be created so do the preliminary
				* initialisation required.  We will not recover if this call
				* fails, but we will report the failure. */
			}
		}
		else
		{
			/* If the scheduler is not already running, make this task the
			* current task if it is the highest priority task to be created
			* so far. */
			pxCurrentTCB = pxNewTCB;
		}
	}
}

static void prvInitialiseNewTask( TaskFunction_t pxTaskCode,
								void * const pvParameters,
								TaskHandle_t * const pxCreatedTask,
								TCB_t * pxNewTCB )
{
	StackType_t * pxTopOfStack;

	/* Calculate the top of stack address.  This depends on whether the stack
	* grows from high memory to low (as per the 80x86) or vice versa.
	* portSTACK_GROWTH is used to make the result positive or negative as required
	* by the port. */
	pxTopOfStack = pxNewTCB->pxStack;

	/* Initialize the TCB stack to look as if the task was already running,
	* but had been interrupted by the scheduler.  The return address is set
	* to the start of the task function. Once the stack has been initialised
	* the top of stack variable is updated. */
	pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );

	if( pxCreatedTask != NULL )
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		* change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
	}
}

BaseType_t xTaskCreate2( TaskFunction_t pxTaskCode,
							void * const pvParameters,
							TaskHandle_t * const pxCreatedTask )
	{
		TCB_t * pxNewTCB;
		BaseType_t xReturn;

		/* If the stack grows down then allocate the stack then the TCB so the stack
		* does not grow into the TCB.  Likewise if the stack grows up then allocate
		* the TCB then the stack. */
		StackType_t * pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = (StackType_t*)&ctx[128];
//                pxStack = ( StackType_t * ) pvPortMallocStack( ( ( ( size_t ) uxStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */

		if( pxStack != NULL )
		{
			/* Allocate space for the TCB. */
			pxNewTCB = (TCB_t*)&ctx[256];
//                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */

			if( pxNewTCB != NULL )
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free
				* it again. */
//                        vPortFreeStack( pxStack );
			}
		}
		else
		{
			pxNewTCB = NULL;
		}

		if( pxNewTCB != NULL )
		{
			prvInitialiseNewTask( pxTaskCode, pvParameters, pxCreatedTask, pxNewTCB );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = 0;
		}
		else
		{
			xReturn = 1;
		}

		return xReturn;
	}


#define portRESTORE_CONTEXT()                                                           \
		__asm__ __volatile__ (  "lds    r26, pxCurrentTCB                       \n\t"   \
								"lds    r27, pxCurrentTCB + 1                   \n\t"   \
								"ld     r28, x+                                 \n\t"   \
								"out    __SP_L__, r28                           \n\t"   \
								"ld     r29, x+                                 \n\t"   \
								"out    __SP_H__, r29                           \n\t"   \
								"pop    r31                                     \n\t"   \
								"pop    r30                                     \n\t"   \
								"pop    r29                                     \n\t"   \
								"pop    r28                                     \n\t"   \
								"pop    r27                                     \n\t"   \
								"pop    r26                                     \n\t"   \
								"pop    r25                                     \n\t"   \
								"pop    r24                                     \n\t"   \
								"pop    r23                                     \n\t"   \
								"pop    r22                                     \n\t"   \
								"pop    r21                                     \n\t"   \
								"pop    r20                                     \n\t"   \
								"pop    r19                                     \n\t"   \
								"pop    r18                                     \n\t"   \
								"pop    r17                                     \n\t"   \
								"pop    r16                                     \n\t"   \
								"pop    r15                                     \n\t"   \
								"pop    r14                                     \n\t"   \
								"pop    r13                                     \n\t"   \
								"pop    r12                                     \n\t"   \
								"pop    r11                                     \n\t"   \
								"pop    r10                                     \n\t"   \
								"pop    r9                                      \n\t"   \
								"pop    r8                                      \n\t"   \
								"pop    r7                                      \n\t"   \
								"pop    r6                                      \n\t"   \
								"pop    r5                                      \n\t"   \
								"pop    r4                                      \n\t"   \
								"pop    r3                                      \n\t"   \
								"pop    r2                                      \n\t"   \
								"pop    __zero_reg__                            \n\t"   \
								"pop    __tmp_reg__                             \n\t"   \
								"out    __SREG__, __tmp_reg__                   \n\t"   \
								"pop    __tmp_reg__                             \n\t"   \
							);

#define portSAVE_CONTEXT()                                                              \
		__asm__ __volatile__ (  "push   __tmp_reg__                             \n\t"   \
								"in     __tmp_reg__, __SREG__                   \n\t"   \
								"cli                                            \n\t"   \
								"push   __tmp_reg__                             \n\t"   \
								"push   __zero_reg__                            \n\t"   \
								"clr    __zero_reg__                            \n\t"   \
								"push   r2                                      \n\t"   \
								"push   r3                                      \n\t"   \
								"push   r4                                      \n\t"   \
								"push   r5                                      \n\t"   \
								"push   r6                                      \n\t"   \
								"push   r7                                      \n\t"   \
								"push   r8                                      \n\t"   \
								"push   r9                                      \n\t"   \
								"push   r10                                     \n\t"   \
								"push   r11                                     \n\t"   \
								"push   r12                                     \n\t"   \
								"push   r13                                     \n\t"   \
								"push   r14                                     \n\t"   \
								"push   r15                                     \n\t"   \
								"push   r16                                     \n\t"   \
								"push   r17                                     \n\t"   \
								"push   r18                                     \n\t"   \
								"push   r19                                     \n\t"   \
								"push   r20                                     \n\t"   \
								"push   r21                                     \n\t"   \
								"push   r22                                     \n\t"   \
								"push   r23                                     \n\t"   \
								"push   r24                                     \n\t"   \
								"push   r25                                     \n\t"   \
								"push   r26                                     \n\t"   \
								"push   r27                                     \n\t"   \
								"push   r28                                     \n\t"   \
								"push   r29                                     \n\t"   \
								"push   r30                                     \n\t"   \
								"push   r31                                     \n\t"   \
								"lds    r26, pxCurrentTCB                       \n\t"   \
								"lds    r27, pxCurrentTCB + 1                   \n\t"   \
								"in     __tmp_reg__, __SP_L__                   \n\t"   \
								"st     x+, __tmp_reg__                         \n\t"   \
								"in     __tmp_reg__, __SP_H__                   \n\t"   \
								"st     x+, __tmp_reg__                         \n\t"   \
							);

static void fast([[maybe_unused]] void* p);

static void slow([[maybe_unused]] void* p)
{
uint8_t PB5_MASK = 0b00100000;
PORTB |= PB5_MASK;
DDRB  |= PB5_MASK;
for (int i = 0; i < 6; i++) {
	_delay_ms(1000);
	PORTB ^= PB5_MASK;
	portSAVE_CONTEXT();
	portRESTORE_CONTEXT();
}

xTaskCreate2(
	fast
	,  NULL
	,  NULL );
portRESTORE_CONTEXT();
__asm__ __volatile__ ( "ret" );
}

static void fast([[maybe_unused]] void* p)
{
uint8_t PB5_MASK = 0b00100000;
PORTB |= PB5_MASK;
DDRB  |= PB5_MASK;
for (int i = 0; i < 50; i++) {
	_delay_ms(100);
	PORTB ^= PB5_MASK;
	portSAVE_CONTEXT();
	portRESTORE_CONTEXT();
}

xTaskCreate2(
	slow
	,  NULL
	,  NULL );
portRESTORE_CONTEXT();
__asm__ __volatile__ ( "ret" );
}


// the setup function runs once when you press reset or power the board
void setup() {
xTaskCreate2(
	fast
	,  NULL
	,  NULL );

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();

	/* Simulate a function call end as generated by the compiler. We will now
	jump to the start of the task the context of which we have just restored. */
	__asm__ __volatile__ ( "ret" );
}
/* ================================================================================================================ */

static void timer_init()
{
	TCCR1B |= (1 << WGM12);					/* Select CTC mode of Timer1 */
	TIMSK1 |= (1 << OCIE1A);				/* Enable timer compare interrupt */
	OCR1AH = 0xFF;							/* Output compare register A high byte */
	OCR1AL = 0xFF;							/* Output compare register A low byte */
	TCCR1B |= (1 << CS12) | (1 << CS10);	/* Timer clock prescaler 1024 */
}

ISR (TIMER1_COMPA_vect)
{
	PORTB ^= PB5_MASK;
}

int main()
{
	PORTB |= PB5_MASK;
	DDRB  |= PB5_MASK;

	timer_init();
	sei();

	while(true) { }

	setup();

	while (true) {
		_delay_ms(2500);
		PORTB ^= PB5_MASK;
	}

	return 0;
}
